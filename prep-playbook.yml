############Setup pre-reqs#############
#https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#variables-discovered-from-systems-facts
- name: Setup Experiment
  connection: ssh
  gather_facts: true
  hosts: all
  vars_files: vars.yml

###Optimizations......
  tasks:
  - set_fact:
      capture_interface_config: "{{ ansible_facts[capture_interface] }}"

  - name: Disable Generic Segmentation Offload
    command: "ethtool -K {{ capture_interface }} gso off"
    become: yes
    when: capture_interface_config['features']['generic_segmentation_offload'] == "on"

  - name: Disable Large Recieve Offload
    command: "ethtool -K {{ capture_interface }} lro off"
    become: yes
    when: capture_interface_config['features']['large_receive_offload'] == "on"

  - name: Disable Generic Recieve Offload
    command: "ethtool -K {{ capture_interface }} gro off"
    become: yes
    when: capture_interface_config['features']['generic_receive_offload'] == "on"

    #More research may be worthwile here
  - name: Disable Rx Checksum Offloding
    command: "ethtool -K {{ capture_interface }} rx off"
    become: yes
    when: capture_interface_config['features']['rx_checksumming'] == "on"

  - name: Set Promiscuous Mode
    command: "ifconfig {{ capture_interface }} promisc"
    become: yes

    #More research may be worthwile here.
    #This appears to be set very low by default for legacy compatibility?
#  - name: Set Rx-Ring Size to Pre-set Maximum
#    command: "ethtool -G {{capture_interface}} rx $(ethtool -g eth0 | grep RX: | head -1)"
#    become: yes
     ignore_errors: yes

    #Multipule rx queues dont make much sense on small boards where the IRQs cant be remapped 
    #the SMP affinity for all of them hits the same core, sorta defeating the purpose
  - name: Limit Number of Hardware Queues
    command: ethtool -L eth1 rx 1
    become: yes
    ignore_errors: yes

   #When Disk I/O is very important. Also lifetime of flash...
  - name: Disable swap on RPis 
    shell: swapoff -a
    become: yes
    when: "'nvidia' not in group_names"
   
  - name: Bump RPi Throttling Temp (3B only)
    shell: echo "temp_soft_limit=70.0" >> /boot/config.txt
    become: yes
    when: "'nvidia' not in group_names"   
   

    #https://www.kernel.org/doc/Documentation/networking/scaling.txt
    #http://christophe.vandeplas.com/2013/11/suricata-capturekerneldrops-caused-by.html
    #irqbalance??
  - name: Determine CPU serving NIC Interrupts
    shell: cat /proc/interrupts | grep -oP "\d+:\s+\K(.+)(?={{capture_interface}})" | tr -s [:space:] "\n" | head -$(grep -c ^processor /proc/cpuinfo) | cat -n | sort -k2rn | head -1 | cut -b5-6
    register: irq_affinity

  - debug:
        msg: "It appears like CPU # {{irq_affinity.stdout_lines|int}} is handling the NIC IRQ"

  - name: Enable / Set Receive Packet Steering Affinity
    shell: "echo {{ bitmasks[irq_affinity.stdout_lines|int] }} > /sys/class/net/{{capture_interface}}/queues/rx-0/rps_cpus"
    become: yes
    ignore_errors: yes

  - name: Set Receive Packet Steering Flow
    shell: "echo 32768 > /proc/sys/net/core/rps_sock_flow_entries && echo 32768 > /sys/class/net/eth0/queues/rx-0/rps_flow_cnt"
    become: yes
    ignore_errors: yes

    #Setting this larger may be better
    #https://community.mellanox.com/s/article/linux-sysctl-tuning
  - name: Set Receive Packet Steering Flow
    shell: sysctl -w net.core.netdev_max_backlog=4096
    become: yes

  - name: Prep Local Send Interface
    local_action:
        module: shell 
        _raw_params: ethtool -A {{ send_interface }} autoneg off tx off rx off

  
  ##build / enable netmap for gen nic


  ##Auto-Scaling for Suricata TODO
  - debug:
        msg: "CPU count for {{ ansible_hostname }} is {{ ansible_facts['processor_count'] }}"
  - debug:
        var: ansible_facts['memory_mb']['nocache']['free']



###Install envrionment
  - name: Install Depends (may take awhile)
    when: ansible_facts['os_family'] == "Debian"
    apt:
      name: "{{ packages }}"
      update_cache: yes
      force_apt_get: yes
    vars:
        packages:
        - lshw
        - build-essential
        - libyaml-0-2
        - libyaml-dev
        - pkg-config
        - zlib1g
        - zlib1g-dev
        - libnet1-dev
        - libpcre3
        - libpcre3-dbg
        - libpcre3-dev
        - libyaml-dev
        - libpcap-dev
        - python-yaml
        - libcap-ng-dev
        - libcap-ng0
        - libmagic-dev
        - liblz4-dev
        - libhtp-dev
        - libjansson-dev
        - libnspr4-dev
        - libnss3-dev
        - rustc
        - libgeoip-dev
        - liblua5.1-dev
        - libhiredis-dev
        - libevent-dev
        - cargo
        - bc
        - git
        - tcpdump
        - python-apt
        - make

  - name: Create Experiment Directory
    file:
      path: "{{ working_dir }}"
      state: directory
      mode: '0777'

  - name: Create Log Directory
    file:
      path: "{{ working_dir }}/log"
      state: directory
      mode: '0777' 

 # - name: Copy Suricata Source
 #   copy:
 #     src: suricata-5.0.0.tar.gz
 #     dest: "{{ working_dir }}"
 #     mode: '0777'

  - name: Unpack Suricata Source
    unarchive:
        src: https://www.openinfosecfoundation.org/download/suricata-5.0.0.tar.gz
        dest: "{{ working_dir }}"
        remote_src: yes

  - name: Run configure
    shell: ./configure --prefix=/usr/ --sysconfdir=/etc/ --localstatedir=/var/
    args:
      chdir: "{{ working_dir }}/suricata-5.0.0"
      creates: "{{ working_dir }}/suricata-5.0.0/Makefile"

 # something wonky happening when done with ansible 
 # - name: Build Suricata Latest
 #   make:
 #     chdir: "{{ working_dir }}/suricata-5.0.0/"
 #   become: yes

 # - name: Install Suricata Latest
 #   make:
 #     chdir: "{{ working_dir }}/suricata-5.0.0/"
 #     target: install-full
 #   become: yes
